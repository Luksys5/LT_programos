#!/bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#-----------------------------------------------------------------------
#$Author: grazulis $
#$Date: 2000/04/28 09:17:01 $ 
#$Locker: grazulis $
#$Revision: 1.1 $
#$Source: /spinne/u108/grazulis/work/RCS/symop_rotaxis,v $
#$State: Exp $
#------------------------------------------------------------------------
#*
# Derive a rotation axis from a rotation matrix of a symmetry operator
#**

use strict;

my $Pi = 3.14159265358979;

# read in the symmetry operator:
#
my @m = map {[split]} grep !/^\s*#|^\s*$/, <>;


# if the translation component of the symmetry operator is missing,
# assume 0 translation:
#
push( @m, [ 0.0, 0.0, 0.0 ] ) unless @m > 3;


#
# find the rotation angle
#

my $cos_a = ( $m[0][0] + $m[1][1] + $m[2][2] - 1 ) / 2;
my $sin_2 = 1 - $cos_a ** 2;
my $sin_a = $sin_2 > 0.0 ? sqrt( $sin_2 ) : 0.0;
my $alpha = atan2( $sin_a, $cos_a );

print "RANGLE\t", $alpha * 180 / $Pi, "\n";

sub submatrix
{
    my ( $row, $column, $matrix ) = @_;
    my @mm;

    my ( $i, $j );
    my $ii = 0;
    for $i (0..2) {
	next if $i == $row;
	my $jj = 0;
	for $j (0..2) {
	    $mm[$ii][$jj++] = $matrix->[$i][$j] if $j != $column;
	}
	$ii ++;
    }
    return \@mm;
}

sub minor
{
    my $m = &submatrix;

    local $[ = 1;
    return
	$m->[1][1] * $m->[2][2]
      - $m->[1][2] * $m->[2][1];
}

sub det3
{
    my $m = $_[0];

    local $[ = 1;
    return
	$m->[1][1] * $m->[2][2] * $m->[3][3]
      + $m->[2][1] * $m->[3][2] * $m->[1][3]
      + $m->[1][2] * $m->[2][3] * $m->[3][1]
      - $m->[1][3] * $m->[2][2] * $m->[3][1]
      - $m->[1][2] * $m->[2][1] * $m->[3][3]
      - $m->[1][1] * $m->[3][2] * $m->[2][3];
}

#
# check whether the axis is a miror axis
#

my $det = det3( \@m );

my $mirror = $det < 0 ? -1 : +1;

#
# calculate an "eigenvalue matrix" p[][]
#
#       [ m11 - 1 , m12,     m13     ]
#   p = [ m21 ,     m22 - 1, m23     ]
#       [ m31 ,     m32,     m33 - 1 ]

my @p;

do {
    my ( $i, $j );
    for $i (0..2) {
	for $j (0..2) {
	    $p[$i][$j] =  $i != $j ? $m[$i][$j] : $m[$i][$j] - 1 * $mirror;
	}
    }
};

#
# Chose the minor of p with a largest absolute value
#

my $maxi;
do {
    $maxi = 0;
    my $max = abs( minor( 0, 0, \@p ));
    my $i;
    for $i ( 1..2 ) {
	my $minor = abs( minor( $i, $i, \@p ));
	if( $minor > $max ) {
	    $max = $minor;
	    $maxi = $i;
	}
    }
};

## do {
##     local $\ = "\n";
##     my $i;
##     for $i (0..2) {
## 	      print minor( $i, $i, \@p );
##     }
##     print "maxi = $maxi";
## };

#
# Construct the matrix of the linear equations to solve
#

my @q;

do {
    my ( $i, $j );
    my $ii = 0;
    for $i (0..2) {
	next if $i == $maxi;
	my $jj = 0;
	for $j (0..2) {
	    $q[$ii][$jj++] = $p[$i][$j] unless $j == $maxi;
	}
	$ii ++;
    }
    $ii = 0;
    for $i (0..2) {
	$q[$ii++][2] = -$p[$i][$maxi] unless $i == $maxi;
    }
};

## do {
##     print "\np:\n";
##     local $\ = "\n";
##     local $, = "\t";
##     for (@p) { print @$_ }
## };
## do {
##     print "\nq:\n";
##     local $\ = "\n";
##     local $, = "\t";
##     for (@q) { print @$_ }
##     print "";
## };

#
# solve the linear equation system @q for the components
# of the axis vector
#

my @v;

sub det2
{
    my $m = $_[0];
    local $[ = 1;
    return
	$m->[1][1] * $m->[2][2]
      - $m->[1][2] * $m->[2][1];
}

do {
    my $denom = det2( \@q );
    ## print "denom = $denom\n";
    if( $denom != 0.0 ) {
	$v[0] = det2( [[ $q[0][2], $q[0][1] ],
		       [ $q[1][2], $q[1][1] ]] ) / $denom;
	$v[1] = det2( [[ $q[0][0], $q[0][2] ],
		       [ $q[1][0], $q[1][2] ]] ) / $denom;
    } else {
	die;
    }
};

#
# check whether the solution satisfies the original equations
#

## printf "# %f\n", $q[0][0] * $v[0] + $q[0][1] * $v[1] - $q[0][2];
## printf "# %f\n", $q[1][0] * $v[0] + $q[1][1] * $v[1] - $q[1][2];

#
# construct the axis vector from the solution
#

my @axis;

do {
    my $ii = 0;
    my $i;
    for $i ( 0..2 ) {
	if( $i == $maxi ) {
	    $axis[$i] = 1.0;
	} else {
	    $axis[$i] = $v[$ii++];
	}
    }
    die unless $ii == 2;
};

#
# Normalize axis so that it is expressed in direction cosini
#

do {
    my $length = sqrt( $axis[0] ** 2 + $axis[1] ** 2 + $axis[2] ** 2 );
    @axis = map { $_ / $length } @axis;
};

#
# check whether the axis satisfies the original equations
#

## do {
##     my @a = @axis;
##     printf "# %f\n", $p[0][0] * $a[0] + $p[0][1] * $a[1] + $p[0][2] * $a[2];
##     printf "# %f\n", $p[1][0] * $a[0] + $p[1][1] * $a[1] + $p[1][2] * $a[2];
##     printf "# %f\n", $p[2][0] * $a[0] + $p[2][1] * $a[1] + $p[2][2] * $a[2];
## };

#
# Find out whether the axis has a correct sign with respect to the
# rotation angle. If not, invert the sign of the axis.
#

do {
    # reconstruct the rotation matrix off-diagonal elements from the
    # rotation angle:
    my $sa = sin( $alpha );
    my $ca = ( 1 - cos( $alpha ));
    my ( @mm, @mp );

    $mp[0][1] = + $sa * $axis[2] + $ca * $axis[0] * $axis[1];
    $mp[0][2] = - $sa * $axis[1] + $ca * $axis[0] * $axis[2];
    $mp[1][2] = + $sa * $axis[0] + $ca * $axis[1] * $axis[2];
    $mp[1][0] = - $sa * $axis[2] + $ca * $axis[0] * $axis[1];
    $mp[2][0] = + $sa * $axis[1] + $ca * $axis[0] * $axis[2];
    $mp[2][1] = - $sa * $axis[0] + $ca * $axis[1] * $axis[2];

    $mm[0][1] = - $sa * $axis[2] + $ca * $axis[0] * $axis[1];
    $mm[0][2] = + $sa * $axis[1] + $ca * $axis[0] * $axis[2];
    $mm[1][2] = - $sa * $axis[0] + $ca * $axis[1] * $axis[2];
    $mm[1][0] = + $sa * $axis[2] + $ca * $axis[0] * $axis[1];
    $mm[2][0] = - $sa * $axis[1] + $ca * $axis[0] * $axis[2];
    $mm[2][1] = + $sa * $axis[0] + $ca * $axis[1] * $axis[2];

    # find the non-diagonal compinent of @m with a largest absolute
    # value:
    my $maxval  = 0;
    my ( $maxi, $maxj );
    my ( $i, $j );
    for $i (0..2) {
	for $j (0..2) {
	    if( $i != $j && abs( $m[$i][$j] ) > $maxval ) {
		$maxval = $m[$i][$j];
		$maxi = $i;
		$maxj = $j;
	    }
	}
    }
    die unless defined $maxi and defined $maxj;
    #
    # check which angel, $alpha or -$alpha, fits better
    #
    if( abs( $m[$maxi][$maxj] - $mp[$maxi][$maxj] ) >
	abs( $m[$maxi][$maxj] - $mm[$maxi][$maxj] ) ) {
	@axis = map {-$_} @axis;
    }
    ## print ">>>> $maxi, $maxj\n";
    ## print ">>>> ", abs( $m[$maxi][$maxj] - $mp[$maxi][$maxj] ), "\n";
    ## print ">>>> ", abs( $m[$maxi][$maxj] - $mm[$maxi][$maxj] ), "\n";
};

#
# print out the final axis
#

do {    
    local $\ = "\n";
    local $, = "\t";
    print "AXIS", @axis;
};

#
# print the axis angles to the coordinate system vectors
#

sub acos
{
    my $c = $_[0];
    return atan2( sqrt( 1 - $c**2 ), $c );
}

print "ANGLES\t";
for (@axis) {
    print acos($_) * 180 / $Pi, "\t";
}
print "\n";

#
# find the screw component of the symmetry operator
#

do {
    local $\ = "\n";
    local $, = "\t";

    my @tr = @{$m[3]};
    my $screw = $axis[0]*$tr[0] + $axis[1]*$tr[1] + $axis[2]*$tr[2];

    print "TSCREW", $screw;
};

#-----------------------------------------------------------------------------

#
# find a stationary point of the operator and print it out
#

#
# fond the translation component without the screw part
#

my @t = @{$m[3]};
my $screw = $axis[0]*$t[0] + $axis[1]*$t[1] + $axis[2]*$t[2];

my @twos = ( # translation without screw:
	     $t[0] - $screw * $axis[0],
	     $t[1] - $screw * $axis[1],
	     $t[2] - $screw * $axis[2],
	   );

my $tlen = sqrt( $twos[0]**2 + $twos[1]**2 + $twos[2]**2 );

if( $tlen < 1E-6 ) {
    print "STATPT\t0.0\t0.0\t0.0\n";
    exit 0;
}

#
# Construct the matrix of the linear equations to solve
#

# matrix @p has been constructed earlier

## my @q;

do {
    my ( $i, $j );
    my $ii = 0;
    for $i (0..2) {
	next if $i == $maxi;
	my $jj = 0;
	for $j (0..2) {
	    $q[$ii][$jj++] = $p[$i][$j] unless $j == $maxi;
	}
	$ii ++;
    }
    $ii = 0;
    for $i (0..2) {
	$q[$ii++][2] = -$p[$i][$maxi] - $twos[$i] unless $i == $maxi;
    }
};

## do {
##     print "\np:\n";
##     local $\ = "\n";
##     local $, = "\t";
##     for (@p) { print @$_ }
## };
## do {
##     print "\nq:\n";
##     local $\ = "\n";
##     local $, = "\t";
##     for (@q) { print @$_ }
##     print "";
## };

#
# solve the linear equation system @q for the components
# of the axis vector
#

## my @v;

do {
    my $denom = det2( \@q );
    ## print "denom = $denom\n";
    if( $denom != 0.0 ) {
	$v[0] = det2( [[ $q[0][2], $q[0][1] ],
		       [ $q[1][2], $q[1][1] ]] ) / $denom;
	$v[1] = det2( [[ $q[0][0], $q[0][2] ],
		       [ $q[1][0], $q[1][2] ]] ) / $denom;
    } else {
	die;
    }
};

#
# check whether the solution satisfies the original equations
#

## printf "# %f\n", $q[0][0] * $v[0] + $q[0][1] * $v[1] - $q[0][2];
## printf "# %f\n", $q[1][0] * $v[0] + $q[1][1] * $v[1] - $q[1][2];

#
# construct the stationaty point vector from the solution
#

my @statpoint;

do {
    my $ii = 0;
    my $i;
    for $i ( 0..2 ) {
	if( $i == $maxi ) {
	    $statpoint[$i] = 1.0;
	} else {
	    $statpoint[$i] = $v[$ii++];
	}
    }
    die unless $ii == 2;
};

#
# find the component of the stationary point radius-vector
# perpendicular to the rotation axis:
#

do {
    my $along_axis = $axis[0] * $statpoint[0] +
	             $axis[1] * $statpoint[1] +
		     $axis[2] * $statpoint[2];

    @statpoint = (
		  $statpoint[0] - $axis[0] * $along_axis,
		  $statpoint[1] - $axis[1] * $along_axis,
		  $statpoint[2] - $axis[2] * $along_axis
		  );
};

do {
    local $\ = "\n";
    local $" = "\t";
    print "STATPT\t@statpoint";
};

## #
## # chech if the point is not moved by the operator
## #
## 
## my @sp = @statpoint;
## 
## my @image = (
##   $sp[0] * $m[0][0] + $sp[1] * $m[0][1] + $sp[2] * $m[0][2] + $twos[0],
##   $sp[0] * $m[1][0] + $sp[1] * $m[1][1] + $sp[2] * $m[1][2] + $twos[1],
##   $sp[0] * $m[2][0] + $sp[1] * $m[2][1] + $sp[2] * $m[2][2] + $twos[2]
## );
## 
## 
## do {
##     print  "#\t$maxi\n";
##     printf "#\t" . ("%10.8f\t"x3) . "\n", 
## 	  $statpoint[0] - $image[0],
## 	  $statpoint[1] - $image[1],
## 	  $statpoint[2] - $image[2];
## };
