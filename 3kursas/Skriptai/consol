#!/bin/sh
#!perl -w
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#-----------------------------------------------------------------------
#  Check for consistent solutions in CCP4 Amore output
#-----------------------------------------------------------------------
#$Author: grazulis $
#$Date: 1997/05/27 16:21:54 $
#$Header:
#$Locker: grazulis $
#$Revision: 1.1 $
#$Source: /kaefer/u05/grazulis/bin/imi,v $
#$State: Exp $
#-----------------------------------------------------------------------
# Look for (resolution, model, etc.) consistent solutions in the output
# of Amore molecular replacement package(s)
#
#INPUT:
#   on the command line, specify several files with amore solutions
#   (each at probably different conditions) the files should have the
#   following format:
#
# SOLUTION     1    91.62    90.91     4.86    36.73   -13.45    62.78 44.1 56.1
# ^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^
#    ignored                  used for "distance" calculation           ignored
#
# blanc lines and lines beginning with '#' sign (comments a-la sh) are ignored 
#
#OUTPUT:
#   MTZ file with integrated (but not scaled) images
#
#-----------------------------------------------------------------------

use strict;
use GetOptions;
use ShowStruct;

my $cutoff;
my $debug = 0;
my $verbose = 1;

getOptions({
   "-c" => \$cutoff,        "--cutoff" => "-c",
   "-d" => sub{$debug=1},   "--debug"  => "-d",
   "-q" => sub{$verbose=0}, "--quite"  => "-q",
   "--verbose" => sub{$verbose=1},
});

print STDERR "Specify the Amore solution files to check on the command line\n"
    and die unless @ARGV > 0;

my @solutions;

while(<>) {
    next if /^\s*$/;
    next if /^\s*#/;
    my @solution = split;
    push( @solutions, { vector => [ @solution[2..7] ], name => $ARGV } );
}

print STDERR int(@solutions), " solutions read\n" if $verbose;

$| = 1;
$" = "\t";
showRef( \@solutions ) if $debug;

#------------------------------------------------------------------------
# build pairs

my @pairs = ();
my ($i, $j);

print STDERR "Building pairs... " if $verbose;
for $i (0..$#solutions - 1) {
    print STDERR "\rBuilding pairs... $i" if $verbose and -t STDERR;
    for $j ($i+1..$#solutions) {
        if( $solutions[$i]{name} ne $solutions[$j]{name} ) {
            my $distance = 
                distance($solutions[$i]{vector}, $solutions[$j]{vector});
    	    push( @pairs, [ $i, $j, $distance ] ) 
                if !defined $cutoff or $distance <= $cutoff;
        }
    }
}

print STDERR "\r" . " "x80 ."\r" if $verbose and -t STDERR; # :-)
print STDERR int(@pairs), " pairs built\n" if $verbose;

print STDERR "Sorting... " if $verbose;

@pairs = sort {$a->[2] <=> $b->[2]} @pairs;

print STDERR "\r" . " "x80 ."\r" if $verbose and -t STDERR; # :-)
print STDERR "Sorting done\n" if $verbose;

$" = "\t";
showRef( \@pairs ) if $debug;

#------------------------------------------------------------------------
# build initial clusters

my $last_distance = 0;
my $cluster_count = 0;
my $clustered_cnt = 0; # number if solutions already assigned into clusters

print STDERR "Forming clusters... " if $verbose;
while (@pairs) {
   my($i, $j) = @{$pairs[0]};

   last if defined $cutoff and $pairs[0][2] > $cutoff;

   $clustered_cnt++ and $last_distance = $pairs[0][2]
     if( !defined $solutions[$j]{cluster} or !defined$solutions[$i]{cluster} );

   $solutions[$i]{cluster} = $solutions[$j]{cluster} 
      if defined $solutions[$j]{cluster} and !defined $solutions[$i]{cluster};

   $solutions[$j]{cluster} = $solutions[$i]{cluster}
      if defined $solutions[$i]{cluster} and !defined $solutions[$j]{cluster};

   $solutions[$j]{cluster} = $solutions[$i]{cluster} = $cluster_count++
      if !defined $solutions[$i]{cluster} and !defined $solutions[$j]{cluster};

} continue {
    shift(@pairs);
}

do {
    printf STDERR "last solution clustered at distance %9.2f\n", 
        $last_distance;
    print STDERR "$cluster_count clusters initially created\n";
} if $verbose;

$" = "\t";
showRef( \@solutions ) if $debug;

#------------------------------------------------------------------------
# transfer the solution vectors to clusters

my @clusters = ();

my $sol;
foreach $sol (@solutions) {
    next unless defined $sol->{cluster};
    my $cluster = $sol->{cluster};
    push( @{$clusters[$cluster]}, $sol );
}

$" = "\t";
showRef( \@clusters ) if $debug;

#------------------------------------------------------------------------
# print nicely the clusters

local $\ = "\n";
my $cluster_cnt = 0;
my $cluster;
foreach $cluster (@clusters) {
    print "Cluster ", ++$cluster_cnt;
    my $solution;
    foreach $solution (@$cluster) {
        printf "%7.2f "x6 . "%s\n", @{$solution->{vector}}, $solution->{name};
    }
    print "";
}

#------------------------------------------------------------------------

sub mod360 { my $x = shift;  $x - int($x) + $x % 360 }

sub distance
{
    my($x, $y) = @_;
    my $d = 0;
    my $i;

    for $i (0..2) {
        $d += mod360($x->[$i] - $y->[$i]) ** 2;
    }

    for $i (3..5) {
        $d += ($x->[$i] - $y->[$i]) ** 2;
    }

    return sqrt($d);

}
